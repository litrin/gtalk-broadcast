#!/usr/bin/env python## Copyright 2007 Google Inc.## Licensed under the Apache License, Version 2.0 (the "License");# you may not use this file except in compliance with the License.# You may obtain a copy of the License at##     http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an "AS IS" BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.#from google.appengine.ext import dbfrom google.appengine.api import memcacheimport loggingclass FriendList(db.Model):    User =  db.EmailProperty()    def add(self, sFriend):        if self.have(sFriend):            return True        else:            DBHandle = FriendList()            DBHandle.User = sFriend            logging.info("%s added!" % sFriend)            return DBHandle.put()    def getAll(self, iSkip=0):        DBHandle = FriendList()        lUser = []        iCount = 0        for oRecord in DBHandle.all().fetch(limit=1000, offset=iSkip):            sUser = oRecord.User            lUser.append(sUser)            iCount += 1        if (iCount == 1000):            lUser = lUser + self.getAll(iSkip + 1000)        return lUser        def getAllUniq(self):        return list(set(self.getAll()))            def have(self, sUser):        DBHandle = FriendList()        for oRecode in DBHandle.all().filter("User = ", sUser).fetch(1):            sLog = '%s is exists!' % sUser            logging.info(sLog)            return True        return False    def delete(self,sUser):        DBHandle = FriendList()        bStatus = db.delete(DBHandle.all().filter("User = ", sUser))        logging.info("%s deleted!" % sUser)                return bStatusclass CacheUserList:        _keyPre = "UL/"    _keyName = None    _quato = ","    def __init__(self, sKey):         self._keyName = self._keyPre + str(sKey)    def add(self, lUser):        sValue = self._quato.join(lUser)        return memcache.add(self._keyName, sValue)    def get(self):        sResult = memcache.get(self._keyName)                if len(sResult) > 1:            try:                lUserList = self._quato.split(sResult)            except:                return None        return lUserList    def pop(self):        lUserList = self.get()        memcache.delete(self._keyName)        return lUserList